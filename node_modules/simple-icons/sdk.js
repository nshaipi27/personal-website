var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var stdin_exports = {};
__export(stdin_exports, {
  SVG_PATH_REGEX: () => SVG_PATH_REGEX,
  collator: () => collator,
  getIconSlug: () => getIconSlug,
  getIconsData: () => getIconsData,
  getIconsDataPath: () => getIconsDataPath,
  getIconsDataString: () => getIconsDataString,
  getThirdPartyExtensions: () => getThirdPartyExtensions,
  getThirdPartyLibraries: () => getThirdPartyLibraries,
  htmlFriendlyToTitle: () => htmlFriendlyToTitle,
  normalizeColor: () => normalizeColor,
  normalizeNewlines: () => normalizeNewlines,
  slugToVariableName: () => slugToVariableName,
  svgToPath: () => svgToPath,
  titleToHtmlFriendly: () => titleToHtmlFriendly,
  titleToSlug: () => titleToSlug
});
module.exports = __toCommonJS(stdin_exports);
var import_promises = __toESM(require("node:fs/promises"));
var import_node_path = __toESM(require("node:path"));
const import_meta = {};
const TITLE_TO_SLUG_REPLACEMENTS = {
  "+": "plus",
  ".": "dot",
  "&": "and",
  \u0111: "d",
  \u0127: "h",
  \u0131: "i",
  \u0138: "k",
  \u0140: "l",
  \u0142: "l",
  \u00DF: "ss",
  \u0167: "t",
  \u00F8: "o"
};
const TITLE_TO_SLUG_CHARS_REGEX = new RegExp(
  `[${Object.keys(TITLE_TO_SLUG_REPLACEMENTS).join("")}]`,
  "g"
);
const TITLE_TO_SLUG_RANGE_REGEX = /[^a-z\d]/g;
const SVG_PATH_REGEX = /^m[-mzlhvcsqtae\d,. ]+$/i;
const getIconSlug = (icon) => icon.slug || titleToSlug(icon.title);
const svgToPath = (svg) => svg.split('"', 8)[7];
const titleToSlug = (title) => title.toLowerCase().replaceAll(
  TITLE_TO_SLUG_CHARS_REGEX,
  (char) => TITLE_TO_SLUG_REPLACEMENTS[char]
).normalize("NFD").replaceAll(TITLE_TO_SLUG_RANGE_REGEX, "");
const slugToVariableName = (slug) => `si${slug[0].toUpperCase()}${slug.slice(1)}`;
const titleToHtmlFriendly = (brandTitle) => brandTitle.replaceAll("&", "&amp;").replaceAll('"', "&quot;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll(/./g, (char) => {
  const charCode = char.codePointAt(0) || 0;
  return charCode > 127 ? `&#${charCode};` : char;
});
const htmlFriendlyToTitle = (htmlFriendlyTitle) => htmlFriendlyTitle.replaceAll(
  /&#(\d+);/g,
  (_, number_) => String.fromCodePoint(Number.parseInt(number_, 10))
).replaceAll(
  /&(quot|amp|lt|gt);/g,
  /**
   * Replace HTML entity references with their respective decoded characters.
   * @param {string} _ Full match.
   * @param {'quot' | 'amp' | 'lt' | 'gt'} reference Reference to replace.
   * @returns {string} Replacement for the reference.
   */
  (_, reference) => ({ quot: '"', amp: "&", lt: "<", gt: ">" })[reference]
);
const getIconsDataPath = () => import_node_path.default.resolve(import_meta.dirname, "data", "simple-icons.json");
const getIconsDataString = () => import_promises.default.readFile(getIconsDataPath(), "utf8");
const getIconsData = async () => {
  const fileContents = await getIconsDataString();
  return JSON.parse(fileContents);
};
const normalizeNewlines = (text) => text.replaceAll("\r\n", "\n");
const normalizeColor = (text) => {
  let color = text.replace("#", "").toUpperCase();
  if (color.length < 6) {
    color = [...color.slice(0, 3)].map((x) => x.repeat(2)).join("");
  } else if (color.length > 6) {
    color = color.slice(0, 6);
  }
  return color;
};
const getThirdPartyExtensions = async () => normalizeNewlines(
  await import_promises.default.readFile(import_node_path.default.join(import_meta.dirname, "README.md"), "utf8")
).split("## Third-Party Extensions")[1].split("|\n\n")[0].split("|\n|").slice(2).map((line) => {
  const [module_, author] = line.split(" | ");
  const module2 = module_.split('<img src="')[0];
  const moduleName = /\[(.+)]/.exec(module2)?.[1];
  if (moduleName === void 0) {
    throw new Error(`Module name improperly parsed from line: ${line}`);
  }
  const moduleUrl = /\((.+)\)/.exec(module2)?.[1];
  if (moduleUrl === void 0) {
    throw new Error(`Module URL improperly parsed from line: ${line}`);
  }
  const authorName = /\[(.+)]/.exec(author)?.[1];
  if (authorName === void 0) {
    throw new Error(`Author improperly parsed from line: ${line}`);
  }
  const authorUrl = /\((.+)\)/.exec(author)?.[1];
  if (authorUrl === void 0) {
    throw new Error(`Author URL improperly parsed from line: ${line}`);
  }
  return {
    module: {
      name: moduleName,
      url: moduleUrl
    },
    author: {
      name: authorName,
      url: authorUrl
    }
  };
});
const getThirdPartyLibraries = async () => normalizeNewlines(
  await import_promises.default.readFile(import_node_path.default.join(import_meta.dirname, "README.md"), "utf8")
).split("## Third-Party Libraries")[1].split("|\n\n")[0].split("|\n|").slice(2).map((line) => {
  let [module2, author] = line.split(" | ");
  module2 = module2.split('<img src="')[0];
  const moduleName = /\[(.+)]/.exec(module2)?.[1];
  if (moduleName === void 0) {
    throw new Error(`Module name improperly parsed from line: ${line}`);
  }
  const moduleUrl = /\((.+)\)/.exec(module2)?.[1];
  if (moduleUrl === void 0) {
    throw new Error(`Module URL improperly parsed from line: ${line}`);
  }
  const authorName = /\[(.+)]/.exec(author)?.[1];
  if (authorName === void 0) {
    throw new Error(`Author improperly parsed from line: ${line}`);
  }
  const authorUrl = /\((.+)\)/.exec(author)?.[1];
  if (authorUrl === void 0) {
    throw new Error(`Author URL improperly parsed from line: ${line}`);
  }
  return {
    module: {
      name: moduleName,
      url: moduleUrl
    },
    author: {
      name: authorName,
      url: authorUrl
    }
  };
});
const collator = new Intl.Collator("en", {
  usage: "search",
  caseFirst: "upper"
});
